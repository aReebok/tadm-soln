#include<iostream>
#include<queue>
#include<vector>
#include <cassert>

/**
 * This is also a leetcode HARD problem:
 *      https://leetcode.com/problems/find-median-from-data-stream/
 * 
 * Now design a data structure that supports the following two operations:
 *       insert(x) -- insert item x from the data stream to the data structure
 *       median() -- return the median of all elements so far
 *   All operations myst take O(logn) time on an n-element set
 * 
 * Solution: This problem is simple, we can use a min heap and max heap to keep track 
 *          of the center values of our array that will point to a median or two values
 *          that we have to average to get a median
 * 
 *          Our [MaxHeap | MinHeap] will be similar to spliting an array into highs/lows
 *          MaxHeap will hold values that are less than or equal to MinHeap. 
 *          example: 
 *          [1, 2, 3, 4, 5] will become
 * 
 *              maxH | minH
 *          [1  2  3 | 4  5]
 *                 *   *
 *          Where the astricks indicate the top element of the heap.
 * 
 *      Note for Insert(x): To avoid a few edge cases and over complicated conditionals:
 *          1. When Insert(x), always insert x into maxH
 *          2. Then always push max from MaxHeap to MinHeap to make sure all elms in MaxH <= MinH
 *          3. Then ensure the size of MinH < MaxH 
 * 
 *      Because of this, when findMedian() is called, we have only 2 cases
 *          1. MaxHeap size > MinHeap size, we return max from MaxHeap
 *          2. otherwise we will only have that the sizes are equal and return (min+max)/2
 * 
 */

class MedianFinder {
private:
    std::priority_queue<int> maxHeap; //default using compairator std::less<int>
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
public:
    MedianFinder() {}

    void insert(int x) {
        // default insert into maxHeap
        maxHeap.push(x);
        // ensure that minHeap.top is always greater than maxHeap.top()
        minHeap.push(maxHeap.top());
        maxHeap.pop();

        // rebalance to maxHeap if minHeap size is greater.
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }

    double median(){
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.top();
        }

        return (maxHeap.top() + minHeap.top()) / 2.0; // return double by dividing by double value
    }

 };

 
 void testMedianFinder() {
    // Test code generated by chatGPT
     MedianFinder mf;
 
     // Test case 1: Insert a single element and check median
     mf.insert(1);
     assert(mf.median() == 1.0);
 
     // Test case 2: Insert another element and check median
     mf.insert(2);
     assert(mf.median() == 1.5);
 
     // Test case 3: Insert another element and check median
     mf.insert(3);
     assert(mf.median() == 2.0);
 
     // Test case 4: Insert more elements and check median
     mf.insert(4);
     assert(mf.median() == 2.5);
 
     mf.insert(5);
     assert(mf.median() == 3.0);
 
     // Test case 5: Insert elements in random order and check median
     MedianFinder mf2;
     mf2.insert(5);
     mf2.insert(15);
     mf2.insert(1);
     mf2.insert(3);
     mf2.insert(8);
     assert(mf2.median() == 5.0);
 
     std::cout << "All test cases passed!" << std::endl;
 }
 
 int main() {
     testMedianFinder();
     return 0;
 }