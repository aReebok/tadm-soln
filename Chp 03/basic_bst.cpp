#include <iostream>
#include <iomanip> 
using namespace std;

struct treenode {
    int val;
    treenode* left;
    treenode* right;
    treenode(int x): val(x), left(nullptr), right(nullptr){}
};

/**
 * Traversals 
 */
void inorder(treenode* root, vector<int>& inorder_store){
    if (!root) return;
    inorder(root->left, inorder_store);
    inorder_store.push_back(root->val);
    inorder(root->right, inorder_store);
}
void preoder(treenode* root, vector<int>& preorder_store) {
    if (!root) return;
    preorder_store.push_back(root->val);
    preoder(root->left, preorder_store);
    preoder(root->right, preorder_store);
}

void postorder(treenode* root, vector<int>& postorder_store) {
    if (!root) return;
    postorder(root->left, postorder_store);
    postorder(root->right, postorder_store);
    postorder_store.push_back(root->val);
}

treenode* search(treenode* root, int key) {
    if (!root || root->val == key) return root;
    if (root->val > key) return search(root->left, key);
    return search(root->right, key);
}   

void insert(treenode*& root, int x) {
    if (!root) {
        root = new treenode(x);
        return;
    }

    if (root->val > x) insert(root->left, x);
    else insert(root->right, x);
}

treenode* remove(treenode* root, int key) {
    // hint: return treenode* new root, because the root may change on delete call
    if (!root) return root;
    if (root->val > key) {
        root->left = remove(root->left, key);
    } else if (root->val < key) {   
        root->right = remove(root->right, key);
    } else { // we've found the node to delete
        // 0 or one children
        if (!root->left) return root->right;
        if (!root->right) return root->left;
        
        // 2 children -> swap with successor node, 
        //                  and delete successor node [left-most node on right subtree]
        treenode* curr = root->right;
        while (curr->left) curr = curr->left;

        root->val = curr->val;
        root->right = remove(root->right, root->val);
    }
    return root;
}







/** 
* TESTING Generated by ChatGPT
*/
void printTestResult(const string& testName, bool passed) {
    int width = 60;  // Total width for alignment
    cout << left << setw(width) << setfill('.') << testName 
         << (passed ? "✅ Passed" : "❌ Failed") << endl;
}

// Helper function for inorder traversal (for debugging)
void inorder(treenode* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

// Test suite
void runTests() {
    cout << "============================ BST TEST SUITE ============================\n";
    cout << left << setw(60) << "Test Case" << "Result" << endl;
    cout << "------------------------------------------------------------------------\n";

    // Initialize tree
    treenode* root = nullptr;

    // Test: Insert
    insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    insert(root, 60);
    insert(root, 80);
    
    printTestResult("Insert: Structure Built", root != nullptr);
    printTestResult("Search 50 (root)", search(root, 50) != nullptr);
    printTestResult("Search 30 (left child)", search(root, 30) != nullptr);
    printTestResult("Search 70 (right child)", search(root, 70) != nullptr);
    printTestResult("Search 100 (non-existent)", search(root, 100) == nullptr);

    // Test: Remove Leaf Node
    root = remove(root, 20);
    printTestResult("Remove Leaf Node (20)", search(root, 20) == nullptr);

    // Test: Remove Node with One Child
    root = remove(root, 30);
    printTestResult("Remove Node with One Child (30)", search(root, 30) == nullptr);

    // Test: Remove Node with Two Children
    root = remove(root, 50);
    printTestResult("Remove Node with Two Children (50)", search(root, 50) == nullptr);

    // Test: Remove Root Node
    root = remove(root, 60);
    printTestResult("Remove Root Node (60)", search(root, 60) == nullptr);

    // Test: Remove Non-Existent Node
    treenode* prevRoot = root;
    root = remove(root, 100);
    printTestResult("Remove Non-Existent Node (100)", root == prevRoot); // Tree should remain unchanged

    cout << "========================================================================\n";
}

int main() {
    runTests();
    return 0;
}